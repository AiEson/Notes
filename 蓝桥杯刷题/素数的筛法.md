# 普通筛法
- 时间复杂度为 $$O(n\log n)$$
## 原理
求解从$[2,N]$这样一个区间范围内的所有素数，可以直接通过筛数法进行筛选。
筛数法指的是假设判断一个数是素数，那么它之后的倍数则一定不是素数。那么就将那些倍数删除掉即可。

- 比如 2 为素数，则后续列表内的 4 6 8 10 12 ... 全都不是素数，直接筛掉即可。
- 同理 3 为素数，后续的 6 9 12 15 ... 也全都不是素数。
## 代码实现
```java
import java.util.Scanner;

public class 素数的筛法 {
    public static void main(String[] args) {
        int n = new Scanner(System.in).nextInt();
        int[] arr = new int[n + 1];
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (arr[i] != -1 && isPrime(i)) {
                for (int j = 2; j*i <= n; j++) {
                    arr[i * j] = -1;
                }
            }
        }
        for (int i = 2; i <= n; i++) {
            if (arr[i] != -1) {
                System.out.print(i + " ");
            }
        }
    }
    public static boolean isPrime(int n) {
        if (n == 2) return true;
        for (int i = 2; i < Math.sqrt(n) + 1; i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```
这个算法可以在 1s 内算出 $10^8$ 以内的所有素数

# 欧氏筛法
时间复杂度为$$O(n)$$
## 原理
### 传统筛法的缺点
很显然，上面的传统筛法是有着*重复计算*的情况的。比如 2 的倍数中含有 6 ，并且 3 的倍数中也含有 6 ，那么 6 这个位置便被重新赋值了。这样会造成一些性能浪费。
### 欧式筛法的原理
- 核心思想为：一个合数只由它的最小质因子来筛选**1**次。
- 任意一个合数都能表示为一个质数另一个数的乘积
- $i = p \times q$，$p$是最小的质因子，若$q$是一个合数，则$q$可以表示为 $x \times y$，$x$是一个质数，且 $x > p$，令 $z = p \times y$，则 $i = p \times q = x \times z$。
	- 于是通过上面的式子可以得到结论：
		- 一个合数与一个质数的乘积，可以表示为一个*更大的*合数和一个*更小的质数*的乘积
### 代码模拟
假设有 2 3 4 5 6 7 8 9
我们定义一个数组$p[]$，其中保存的我们找到的所有素数。$p$的第一个值人为设定为 $2$。
那么找到第一个数字 $2$ 之后，我们需要找它的质因数，也就是 $2$，然后相乘得 $4$，从而 $4$ 不是质数。此时列表变成
2 3 5 6 7 8 9
此时考虑下一个数字 $3$，它的质因数为$2, 3$，那么  删掉，$2 \times 3 = 6, 3\times3 = 9$。此时变成

2 3 5 7 8

下一个数字 $4$ ，它的质因数为$2$，所以$2\times4 = 8$被删掉。即

2 3 5 7。

## 代码实现

```java
import java.util.Scanner;

public class 素数的筛法 {
    public static void main(String[] args) {
        int n = new Scanner(System.in).nextInt();
        int[] arr = new int[n + 1];
        int[] p = new int[n + 1];
        int cnt = 0;
        for (int i = 2; i <= n; i++) {
            if (arr[i] == 0) p[++cnt] = i;
            for (int j = 1; j <= cnt && i * p[j] <= n; j++) {
                arr[i * p[j]] = -1;
                if (i % p[j] == 0) break;
            }
        }
        for (int i = 1; i <= cnt; i++) {
            System.out.print(p[i] + " ");
        }
    }
}
```



