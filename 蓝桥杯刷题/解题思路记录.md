# 解题思路
## 学院OJ
### 题目：特殊的质数肋骨
#### 题干描述
农民约翰母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始切下肋骨，每次还剩下的肋骨上的数字都组成一个质数。  
  
 例如有四根肋骨的数字分别是：7 3 3 1，那么全部肋骨上的数字 7331是质数；三根肋骨 733是质数；二根肋骨 73 是质数；当然,最后一根肋骨 7 也是质数。7331 被叫做长度 4 的特殊质数。  
  
 写一个程序对给定的肋骨的数目 N (1<=N<=8),求出所有的特殊质数。数字1不被看作一个质数。
 #### 输入
 ```
 4
 ```
 #### 输出
 ```
2333  
2339  
2393  
2399  
2939  
3119  
3137  
3733  
3739  
3793  
3797  
5939  
7193  
7331  
7333  
7393
```
#### 思路
那么既然要保证每一位都是质数，那么直接从每一位加入数字之后进行判断是否为质数即可。
要实现一个算法为`boolean isPrime(int n)`
```java
public static boolean isPrime(int n) {  
 if (n == 1) return false;  
 if (n == 2) return true;  
 for (int i = 3; i < Math.sqrt(n) + 1; i++) {  
 if (n % i == 0) return false;  
 } return true;  
}
```
接下来使用递归函数`generatePrime(int now, int ndeep)`进行数字的生成操作，配合`isPrime(int n)`算法。只需要遍历0~9十个数字，当这个数字加上之前的数字为质数的时候，才继续向后生成。
```java
public static void generatePrime(int now, int ndeep){  
 //递归停止的条件  
 if (deep == ndeep){  
 if (isPrime(now)) {  
 list.add(now);  
 return;  
 } } if (ndeep == 0) {  
 //2 3 5 7  
 generatePrime(2, 1);  
 generatePrime(3, 1);  
 generatePrime(5, 1);  
 generatePrime(7, 1);  
 } else {  
 for (int i = 0; i < 10; i++) {  
 int n = now * 10 + i;  
 if (isPrime(n)) {  
 generatePrime(n, ndeep + 1);  
 } } }  
}
```
直接遍历输出list即可。

### 题目：找素数
#### 题干描述
给定区间  [L, R]  ， 请计算区间中素数的个数。
 #### 输入
 输入描述:  
 两个数L和R。  
输入样例:  
 ```
 2 11
 ```
 #### 输出
 输出描述:  
 一行，区间中素数的个数。  
输出样例:
 ```
 5
 ```
#### 思路
~~直接使用`isPrime(n)` 算法进行素数判断，然后通过计数输出结果。~~
这样是不行的！因为数据超时。需要进行优化。
首先通过`isPrime(n)`找出第一个在这个区间里最小的那个素数，然后通过动态规划找出其他素数。

